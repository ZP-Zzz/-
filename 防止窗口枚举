//NtUserQueryWindow
//NtUserFindWindowEx
//NtUserBuildHwndList
#include <ntddk.h>
#include <windef.h>

#define	DEVICE_NAME			L"\\Device\\Fuck3SDT"
#define LINK_NAME			L"\\DosDevices\\Fuck3SDT"
#define LINK_GLOBAL_NAME	L"\\DosDevices\\Global\\Fuck3SDT"

#define IOCTL_HOOK		CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS) //In LONG
#define IOCTL_UNHOOK	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS) //In BSTR

#pragma intrinsic(__readmsr)

typedef struct _SYSTEM_SERVICE_TABLE {
	PVOID  		ServiceTableBase;
	PVOID  		ServiceCounterTableBase;
	ULONGLONG  	NumberOfServices;
	PVOID  		ParamTableBase;
} SYSTEM_SERVICE_TABLE, * PSYSTEM_SERVICE_TABLE;


typedef DWORD(*NTUSERQUERYWINDOW)(HWND	WindowHandle,LPDWORD	TypeInformation);
typedef HWND(*NTUSERFINDWINDOWA)(IN ULONG hwndParent,IN ULONG hwndChild,IN PUNICODE_STRING pstrClassName OPTIONAL,IN PUNICODE_STRING pstrWindowName OPTIONAL,IN ULONG dwType);
typedef NTSTATUS(*NTUSERBUILDHWNDLIST)(IN HDESK hdesk,IN HWND hwndNext,IN ULONG fEnumChildren,IN DWORD idThread,IN UINT cHwndMax,OUT HWND* phwndFirst,OUT ULONG* pcHwndNeeded);


PSYSTEM_SERVICE_TABLE KeServiceDescriptorTableShadow = NULL;
ULONG64	ul64W32pServiceTable = 0;
ULONG64	IndexOfNtUserFindWindowEx = 0x106C;  //108   108变成16进制 = 6C，再加上0x1000 = 0x106C
ULONG64	IndexOfNtUserQueryWindow = 0x1010;  //16
ULONG64 IndexOfNtUserBuildHwndList = 0x101C; //28    
NTUSERQUERYWINDOW NtUserQueryWindow = NULL;
NTUSERFINDWINDOWA NtUserFindWindowEx = NULL;
NTUSERBUILDHWNDLIST NtUserBuildHwndList = NULL;
ULONG64	MyProcessId = 0;
ULONG64	IndexOfNtUserWindowFromPhysicalPoint = 0x151F;  //1311
ULONG64 AddressNtUserWindowFromPhysicalPoint = 0;


KIRQL WPOFFx64()
{
	KIRQL irql = KeRaiseIrqlToDpcLevel();
	UINT64 cr0 = __readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);
	_disable();
	return irql;
}
void WPONx64(KIRQL irql)
{
	UINT64 cr0 = __readcr0();
	cr0 |= 0x10000;
	_enable();
	__writecr0(cr0);
	KeLowerIrql(irql);
}
ULONGLONG GetKeServiceDescriptorTableShadow64()
{
	PUCHAR StartSearchAddress = (PUCHAR)__readmsr(0xC0000082);
	PUCHAR EndSearchAddress = StartSearchAddress + 0x500;
	PUCHAR i = NULL;
	UCHAR b1 = 0, b2 = 0, b3 = 0;
	ULONG templong = 0;
	ULONGLONG addr = 0;
	for (i = StartSearchAddress; i < EndSearchAddress; i++)
	{
		if (MmIsAddressValid(i) && MmIsAddressValid(i + 1) && MmIsAddressValid(i + 2))
		{
			b1 = *i;
			b2 = *(i + 1);
			b3 = *(i + 2);
			if (b1 == 0x4c && b2 == 0x8d && b3 == 0x1d) //4c8d1d
			{
				memcpy(&templong, i + 3, 4);
				addr = (ULONGLONG)templong + (ULONGLONG)i + 7;
				return addr;
			}
		}
	}
	return 0;
}
ULONGLONG GetSSSDTFuncCurAddr64(ULONG64 Index)
{
	ULONGLONG				W32pServiceTable = 0, qwTemp = 0;
	LONG 					dwTemp = 0;
	PSYSTEM_SERVICE_TABLE	pWin32k;
	pWin32k = (PSYSTEM_SERVICE_TABLE)((ULONG64)KeServiceDescriptorTableShadow + sizeof(SYSTEM_SERVICE_TABLE));
	W32pServiceTable = (ULONGLONG)(pWin32k->ServiceTableBase);
	ul64W32pServiceTable = W32pServiceTable;
	qwTemp = W32pServiceTable + 4 * (Index - 0x1000);	//这里是获得偏移地址的位置，要HOOK的话修改这里即可
	dwTemp = *(PLONG)qwTemp;
	dwTemp = dwTemp >> 4;
	qwTemp = W32pServiceTable + (LONG64)dwTemp;
	return qwTemp;
}
VOID ListAllShadowFunctionAddress()
{
	ULONGLONG				W32pServiceTable = 0, FunctionCount = 0, i = 0, Index = 0;
	ULONGLONG				qwTemp = 0;
	LONG					dwTemp;
	PSYSTEM_SERVICE_TABLE	pWin32k;
	pWin32k = (PSYSTEM_SERVICE_TABLE)((ULONG64)KeServiceDescriptorTableShadow + 4 * 8);
	W32pServiceTable = (ULONGLONG)(pWin32k->ServiceTableBase);
	FunctionCount = pWin32k->NumberOfServices;
	for (i = 0; i < FunctionCount; i++)
	{
		Index = 0x1000 + i;
		qwTemp = W32pServiceTable + 4 * (Index - 0x1000);	//DbgPrint("qwTemp: %llx",qwTemp);
		dwTemp = *(PLONG)qwTemp;
		dwTemp = dwTemp >> 4;
		qwTemp = W32pServiceTable + (LONG64)dwTemp;
		DbgPrint("Address[%d]: %llx",i, qwTemp);
	}
}
VOID ModifySSSDT(ULONG64 Index, ULONG64 Address)
{
	ULONGLONG				W32pServiceTable = 0, qwTemp = 0;
	LONG 					dwTemp = 0;
	PSYSTEM_SERVICE_TABLE	pWin32k;
	KIRQL					irql;
	pWin32k = (PSYSTEM_SERVICE_TABLE)((ULONG64)KeServiceDescriptorTableShadow + sizeof(SYSTEM_SERVICE_TABLE));	//4*8
	W32pServiceTable = (ULONGLONG)(pWin32k->ServiceTableBase);
	qwTemp = W32pServiceTable + 4 * (Index - 0x1000);
	dwTemp = (LONG)(Address - W32pServiceTable);
	dwTemp = dwTemp << 4;	//DbgPrint("*(PLONG)qwTemp: %x, dwTemp: %x",*(PLONG)qwTemp,dwTemp);
	irql = WPOFFx64();
	*(PLONG)qwTemp = dwTemp;
	WPONx64(irql);
}
VOID FuckFunc()
{
	KIRQL irql;         //（xor rax,rax + ret）
	UCHAR fuckcode[] = "\x48\x33\xC0\xC3\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
	irql = WPOFFx64();
	memcpy((PVOID)AddressNtUserWindowFromPhysicalPoint, fuckcode,26);	//覆盖26个字节【保持指令完整性】
	WPONx64(irql);
}


//自己的函数
HWND  MyNtUserFindWindowEx(IN ULONG hwndParent, IN ULONG hwndChild, IN PUNICODE_STRING pstrClassName OPTIONAL, IN PUNICODE_STRING pstrWindowName OPTIONAL, IN ULONG dwType)
{
	//DbgPrint("NtUserFindWindowEx(%d, %d, %wZ, %wZ, %d)\n", hwndParent, hwndChild, pstrClassName, pstrWindowName, dwType);
	UNICODE_STRING Classname ;
	RtlInitUnicodeString(&Classname, L"HLBRMainUI");
	if (pstrClassName != 0 )
	{
		if ((RtlCompareUnicodeString(pstrClassName, &Classname, TRUE) == 0))
		{
			return 0;
		}
		else
		{
			return NtUserFindWindowEx(hwndParent, hwndChild, pstrClassName, pstrWindowName, dwType);
		}
	}
	else
	{
		return NtUserFindWindowEx(hwndParent, hwndChild, pstrClassName, pstrWindowName, dwType);
	}
}

DWORD MyNtUserQueryWindow(HWND hWnd, LPDWORD lpdwProcessId)
{
	if (hWnd == 263012)
	{
		return 0;
	}
	else
	{
		return NtUserQueryWindow(hWnd,lpdwProcessId);
	}
}

NTSTATUS MyNtUserBuildHwndList(IN HDESK hdesk, IN HWND hwndNext, IN ULONG fEnumChildren, IN DWORD idThread, IN UINT cHwndMax, OUT HWND* phwndFirst, OUT ULONG* pcHwndNeeded)
{
	NTSTATUS result;

	if (PsGetCurrentProcessId() != (HANDLE)6088)
	{
		ULONG ProcessID;

		if (fEnumChildren == 1)
		{
			ProcessID = NtUserQueryWindow(hwndNext, 0);
			if (ProcessID == (ULONG)6088)
				return STATUS_UNSUCCESSFUL;
		}
		result = NtUserBuildHwndList(hdesk, hwndNext, fEnumChildren, idThread, cHwndMax, phwndFirst, pcHwndNeeded);

		if (result == STATUS_SUCCESS)
		{
			ULONG i = 0;
			ULONG j;

			while (i < *pcHwndNeeded)
			{
				ProcessID = NtUserQueryWindow(phwndFirst[i], 0);
				if (ProcessID == (ULONG)6088)
				{
					for (j = i; j < (*pcHwndNeeded) - 1; j++)
						phwndFirst[j] = phwndFirst[j + 1];

					phwndFirst[*pcHwndNeeded - 1] = 0;

					(*pcHwndNeeded)--;
					continue;
				}
				i++;
			}

		}
		return result;
	}
	return NtUserBuildHwndList(hdesk, hwndNext, fEnumChildren, idThread, cHwndMax, phwndFirst, pcHwndNeeded);
}




VOID HOOK_SSSDT()
{
	KIRQL irql;
	ULONG64 myfun1, myfun2, myfun3;    //jmp qword [rip]
	UCHAR jmp_code1[] = "\xFF\x25\x00\x00\x00\x00\x90\x90\x90\x90\x90\x90\x90\x90";	//需要14字节+4字节
	UCHAR jmp_code2[] = "\xFF\x25\x00\x00\x00\x00\x90\x90\x90\x90\x90\x90\x90\x90";	//需要14字节+4字节
	UCHAR jmp_code3[] = "\xFF\x25\x00\x00\x00\x00\x90\x90\x90\x90\x90\x90\x90\x90";	//需要14字节+4字节
	//代理函数地址
	myfun1 = (ULONGLONG)MyNtUserFindWindowEx;
	myfun2 = (ULONGLONG)MyNtUserQueryWindow;
	myfun3 = (ULONGLONG)MyNtUserBuildHwndList;
	//填充shellcode
	memcpy(jmp_code1 + 6, &myfun1, 8);    //jmp_code = jmp qword [MyNtUserPostMessage]
	memcpy(jmp_code2 + 6, &myfun2, 8);    //jmp_code = jmp qword [MyNtUserPostMessage]
	memcpy(jmp_code3 + 6, &myfun3, 8);    //jmp_code = jmp qword [MyNtUserPostMessage]
	//写入shellcode
	FuckFunc();

	//AddressNtUserWindowFromPhysicalPoint:
	//xor rax,rax   
	//ret   
	//jmp qword [MyNtUserPostMessage]
	irql = WPOFFx64();           
	memcpy((PVOID)(AddressNtUserWindowFromPhysicalPoint + 4), jmp_code1, 14); 
	WPONx64(irql);
	ModifySSSDT(IndexOfNtUserFindWindowEx, AddressNtUserWindowFromPhysicalPoint + 4);

	/*irql = WPOFFx64();
	memcpy((PVOID)(AddressNtUserWindowFromPhysicalPoint + 18), jmp_code2, 14);
	WPONx64(irql);
	ModifySSSDT(IndexOfNtUserQueryWindow, AddressNtUserWindowFromPhysicalPoint + 18);*/

	irql = WPOFFx64();
	memcpy((PVOID)(AddressNtUserWindowFromPhysicalPoint + 18), jmp_code3, 14);
	WPONx64(irql);
	ModifySSSDT(IndexOfNtUserBuildHwndList, AddressNtUserWindowFromPhysicalPoint + 18);
	DbgPrint("HOOK_SSSDT OK!");
}

VOID UNHOOK_SSSDT()
{
	ListAllShadowFunctionAddress();
	ModifySSSDT(IndexOfNtUserFindWindowEx, (ULONG64)NtUserFindWindowEx);
	ModifySSSDT(IndexOfNtUserQueryWindow, (ULONG64)NtUserQueryWindow);
	ModifySSSDT(IndexOfNtUserBuildHwndList, (ULONG64)NtUserBuildHwndList);
	DbgPrint("UNHOOK_SSSDT OK!");
}


VOID DriverUnload(PDRIVER_OBJECT pDriverObj)
{
	UNICODE_STRING strLink;
	RtlInitUnicodeString(&strLink, LINK_NAME);
	IoDeleteSymbolicLink(&strLink);
	IoDeleteDevice(pDriverObj->DeviceObject);
}
NTSTATUS DispatchCreate(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
NTSTATUS DispatchClose(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}


NTSTATUS DispatchIoctl(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
	PIO_STACK_LOCATION pIrpStack;
	ULONG uIoControlCode;
	PVOID pIoBuffer;
	ULONG uInSize;
	ULONG uOutSize;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	uIoControlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
	pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
	uInSize = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	uOutSize = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
	switch (uIoControlCode)
	{
	case IOCTL_HOOK:
	{
		MyProcessId = (ULONG64)PsGetCurrentProcessId();	
		DbgPrint("MyProcessId: %ld", MyProcessId);

		NtUserQueryWindow = (NTUSERQUERYWINDOW)GetSSSDTFuncCurAddr64(IndexOfNtUserQueryWindow);
		DbgPrint("NtUserQueryWindow: %llx", (ULONG64)NtUserQueryWindow);

		NtUserFindWindowEx = (NTUSERFINDWINDOWA)GetSSSDTFuncCurAddr64(IndexOfNtUserFindWindowEx);
		DbgPrint("NtUserFindWindowEx: %llx", (ULONG64)NtUserFindWindowEx);

		NtUserBuildHwndList = (NTUSERBUILDHWNDLIST)GetSSSDTFuncCurAddr64(IndexOfNtUserBuildHwndList);
		DbgPrint("NtUserBuildHwndList: %llx", (ULONG64)NtUserBuildHwndList);

		AddressNtUserWindowFromPhysicalPoint = GetSSSDTFuncCurAddr64(IndexOfNtUserWindowFromPhysicalPoint);
		DbgPrint("AddressNtUserWindowFromPhysicalPoint: %llx", (ULONG64)AddressNtUserWindowFromPhysicalPoint);

		HOOK_SSSDT();
		status = STATUS_UNSUCCESSFUL;
		break;
	}
	case IOCTL_UNHOOK:
	{
		UNHOOK_SSSDT();
		status = STATUS_UNSUCCESSFUL;
		break;
	}
	}
	if (status == STATUS_SUCCESS)
		pIrp->IoStatus.Information = uOutSize;
	else
		pIrp->IoStatus.Information = 0;
	pIrp->IoStatus.Status = status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return status;
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegistryString)
{
	NTSTATUS status = STATUS_SUCCESS;
	UNICODE_STRING ustrLinkName;
	UNICODE_STRING ustrDevName;
	PDEVICE_OBJECT pDevObj;
	pDriverObj->MajorFunction[IRP_MJ_CREATE] = DispatchCreate;
	pDriverObj->MajorFunction[IRP_MJ_CLOSE] = DispatchClose;
	pDriverObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchIoctl;
	pDriverObj->DriverUnload = DriverUnload;
	RtlInitUnicodeString(&ustrDevName, DEVICE_NAME);
	status = IoCreateDevice(pDriverObj, 0, &ustrDevName, FILE_DEVICE_UNKNOWN, 0, FALSE, &pDevObj);
	if (!NT_SUCCESS(status))	return status;
	if (IoIsWdmVersionAvailable(1, 0x10))
		RtlInitUnicodeString(&ustrLinkName, LINK_GLOBAL_NAME);
	else
		RtlInitUnicodeString(&ustrLinkName, LINK_NAME);
	status = IoCreateSymbolicLink(&ustrLinkName, &ustrDevName);
	if (!NT_SUCCESS(status))
	{
		IoDeleteDevice(pDevObj);
		return status;
	}
	KeServiceDescriptorTableShadow = (PSYSTEM_SERVICE_TABLE)GetKeServiceDescriptorTableShadow64();
	return STATUS_SUCCESS;
}
